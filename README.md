# 오브젝트
* 코틀린으로 오브젝트 내용을 정리 및 실습

## 목차


## 챕터 1 요약
```
* 모듈이 가져야 하는 세가지 기능 by 로버트 마틴
  * [v] 제대로 동작하는 것
  * [v] 변경을 위해 존재하는 것
  * [v] 코드를 읽는 사람과 의사소통 하는 것
* 책임의 이동
  * 책임이 하나의 요소에 중앙집중 : 타 모듈간의 의존성이 높다. 결합도 크다.
  * 책임이 여러 요소에 분산배치
* 적절한 트레이드 오프
  * 결합도를 높이는 대신에 객체의 자율성을 부여할 것인지
  * 결합도를 낮추는 대신에 객체의 자율성을 상실할 것인지
* 현실에서 수동적인 존재들도 객체지향의 세계로 들어오면 능동적이고 자율적인 존재로 변하게 된다.
```

## 챕터 2 요약
```
* 어떤 클래스가 필요한지 생각하기 보다는 어떤 객체가 필요한지에 주안을 둔다.
  * 어떤 객체가 상태화 어느 상태와 행위를 가지는지 생각한다.
* 클래스의 경계를 구분짓는 것은 중요하다.
  * 객체 내부의 접근을 통제하는 이유는 객체를 자율적인 존재로 만들어주기 위해서다.
    * 객체 지향의 핵심은 객체가 스스로 상태관리, 판단, 행동을 하도록 하는 것이다.
  * 클래스의 작성자가 내부 구현을 은닉하게 해준다.
  * 클라이언트 프로그래머가 실수로 숨겨진 부분을 접근하는 것을 막아준다.
  * 클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용하는 사람
* 설계가 필요한 이유는 변경을 관리하기 위해서다.
* 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행시점의 의존성이 다르다는 것이다. (컴파일/런타임 의존성)
  * (중요) P.59 장
* 메시지와 메소드는 다른 개념이다.
  * 동일한 메세지를 전달하지만, 메소드의 실행은 클래스가 무엇이냐에 따라 결정된다. : 다형성
  * 동일한 메시지를 전달하지만, 실행시점에 결정한다. : 지연 바인딩 또는 동적 바인딩
* 추상화
  * 추상화를 이용하면 요구사항을 높은 정책으로 서술할 수 있다.
  * 추상화를 이용하면 설계가 좀 더 유연해질 수 있다.
  * (중요) P.65장 ~ 66장
* (중요) 프로그래밍 관점에 너무 치우져, 객체지향을 바라볼 경우 객체지향의 본질을 놓치기 쉽다. 
  * 객체를 바라보는 것에서 객체지향은 시작이다.
  * 객체들의 상호작용과 협력이 중요하다.
```

## 느낀 것.
```
* data class 는 필요한 경우에만 쓰고, 클래스의 내/외부 경계를 위해 기본 class 에 private 지정자를 포함한 생성자를 만들어 받도록 한다.
  * 생성자로 받도록 하였는데 get 이 필요하다면 private 은 제거하도록 한다.
```